import socket
import time

# 扫描127.0.0.1开放的端口
# 用端口模拟局域网的主机
def get_ip_status(ip,port,portlist):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        server.connect((ip,port))
        portlist.append(port)
        print('{0} port {1} is open'.format(ip, port))
    except Exception as err:
        print('{0} port {1} is not open'.format(ip,port))
    finally:
        server.close()
# 对开放的端口（相当于服务器），逐个攻击，发送字符串
# 假设有缓冲区溢出漏洞的服务器，缓冲区size小于1024字节
# 发送64-1024字节，如果过程中连接中断，认为服务器发生了栈溢出，说明该服务器为具有设计好的漏洞的机器
# 打印中断链接时的 A的个数，可以判断出缓冲区大小
# 达到1024字节还不溢出认为没有该漏洞
def stackov(ip,portlist):
    for port in portlist:
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.connect((ip,port))
        print('{0} port {1} is undertesting'.format(ip, port))
        ovstr='A'
        for i in range(64,1024): #假定，缓冲区溢出范围在64-1024字节，逐个尝试
            msg=ovstr+'\n'
            server.send(msg.encode(encoding='utf-8'))
            print("count A: %d \n" % i)  # 把接收到的数据进行解码
            ovstr=ovstr+'A'
            time.sleep(2)
        server.close()
        print('finished')
if __name__ == '__main__':
    portlist=[]
    host = '127.0.0.1'
    for port in range(12300,12400):
        get_ip_status(host,port,portlist)
    stackov(host,portlist)